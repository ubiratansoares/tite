{
    "docs": [
        {
            "location": "/",
            "text": "TITE\n\u00b6\n\n\n\n\nA Kotlin DSL for gorgeous RxJava2 tests\n\n\n\n\nMotivation\n\u00b6\n\n\nRxJava2 gives us a handy testing API : besides \nTestSubscriber\n and \nTestObserver\n, you also have a built-in \ntest()\n API method available for every available reactive type, that shortcuts the retrieval of a \nTestObserver\n or \nTestSubscriber\n instance and streamlines your testing flow.  \n\n\nval letters = Observable.just(\"A\",\"B\",\"C\")\n\nletters\n    .test()\n    .assertValueCount(3)\n    .assertComplete()\n\n\n\n\nBoth \nTestSubscriber\n and \nTestObserver\n assertions let you get your tests done; but after using these APIs for a while, you may figure out they are not perfect ... \n\n\nNevertheless, Kotlin empowers developers with a new world of possibilities, including a new field of DSL grammars using language features like \ninfix notation\n for functions representations, \nlambdas extensions\n over instance types and others.\n\n\nWith this in mind, Tite was born. It aims to apply some grammar over \n\nTestSubscriber\n and \nTestObserver\n APIs while improving these APIs discoverability as well.\n\n\nSource Code\n\u00b6\n\n\nCheck it on \nGithub\n\n\nSetup\n\u00b6\n\n\nFor now, Tite is available through Jitpack. To add it into your project :\n\n\n\n\nSetup Jitpack as a Maven repository\n\n\n\n\nallprojects {\n    repositories {\n        ...\n        maven { url 'https://jitpack.io' }\n    }\n}\n\n\n\n\n\n\nAdd this library to your dependencies. For an Android project\n\n\n\n\ndependencies {\n    implementation 'com.github.ubiratansoares.tite:tite:$version'\n}\n\n\n\n\nCheck this project \nreleases\n for the latest version.\n\n\nThis library will be available at Maven Central soon, I`m looking for some community feedback.\n\n\nDSL Design\n\u00b6\n\n\nTite DSL assumes that intentions for testing some reactive-type are grouped, under the following DSL blocks\n\n\nConditions before performing verifications\n\u00b6\n\n\nval\n \ntarget\n \n=\n \nObservable\n.\nrange\n(\n1\n,\n \n5\n)\n\n\n\ngiven\n(\ntarget\n)\n \n{\n\n    \nbeforeChecksAwait\n \n{\n\n        \nuntilEmissions\n \nreach\n \n2\n \n// will ignore first two items\n\n    \n}\n\n\n}\n\n\n\n\n\nVerifying emmited values\n\u00b6\n\n\nval\n \nnumbers\n \n=\n \nObservable\n.\njust\n(\n1\n,\n \n2\n,\n \n3\n)\n\n\n\ngiven\n(\nnumbers\n)\n \n{\n\n    \nverifyForEmissions\n \n{\n\n        \nitems\n \nmatch\n \nsequenceOf\n(\n1\n,\n \n2\n,\n \n3\n)\n\n    \n}\n\n\n}\n\n\n\n\n\nVerifying signaled error\n\u00b6\n\n\nval\n \nexpectedReason\n \n=\n \nIllegalStateException\n(\n\"Ouch!\"\n)\n\n\nval\n \nbroken\n \n=\n \nFlowable\n.\nerror\n<\nAny\n>(\nreason\n)\n\n\n\ngiven\n(\nbroken\n)\n \n{\n\n    \nverifyWhenError\n \n{\n\n        \nfails\n \nbyError\n \nexpectedReason\n\n    \n}\n\n\n}\n\n\n\n\n\nVerifying lifecycle of a sequence\n\u00b6\n\n\nval\n \nneverStarts\n \n=\n \nCompletable\n.\nnever\n()\n\n\n\ngiven\n(\nneverStarts\n)\n \n{\n\n    \nassertThatSequence\n \n{\n\n        \nshould\n \nnotBe\n \nterminated\n\n    \n}\n\n\n}\n\n\n\n\n\nMixed verifications\n\u00b6\n\n\nOf course, you can mix all this blocks under the same unit test context, putting some structure over the \nfluent-and-chainable\n way of traditional Java\n\n\nval\n \nwords\n \n=\n \nObservable\n.\njust\n(\n\"Adenor\"\n,\n \n\"Leonardo\"\n,\n \n\"Bacchi\"\n)\n\n\n\ngiven\n(\nwords\n)\n \n{\n\n\n    \nbeforeChecksAwait\n \n{\n\n        \ncountingTime\n \nuntil\n \n3.\nseconds\n\n    \n}\n\n\n    \nassertThatSequence\n \n{\n\n        \nshould\n \nbe\n \ncompleted\n\n        \nshould\n \nbe\n \nterminated\n\n        \nshould\n \nnotBe\n \nbroken\n\n        \nshould\n \nbe\n \nsubscribed\n\n    \n}\n\n\n    \nverifyForEmissions\n \n{\n\n        \nitems\n \nmatch\n \nsequenceOf\n(\n\"Adenor\"\n,\n \n\"Leonardo\"\n,\n \n\"Bacchi\"\n)\n\n        \nfirstItem\n \nshouldBe\n \n\"Adenor\"\n\n        \nnever\n \nemmits\n \n\"Parreira\"\n\n        \nnever\n \nemmits\n \n\"Felip\u00e3o\"\n\n    \n}\n\n\n}\n\n\n\n\n\nIf you want to learn all convered RxJava2 testing APIs without exploring the DSL itself, please, refer to this DSL unit tests .\n\n\nBuilding\n\u00b6\n\n\nIn order to hack-and-mess with this library, we recommend\n\n\n\n\nIntellijIDEA with Kotlin plugin \n1.2.51\n or newer\n\n\n\n\nThis library is builded with Gradle. The IDE should integrate seamlessly with this project via the default \nGradle wrapper\n.\n\n\nIs this library used by someone / somewhere ?\n\u00b6\n\n\nYes. At \nStone\n we are using it extensively into some new products (to be launched soon! \ud83d\ude80), but this library concept (and practical field validation) is older than those products, mine own, and I decided to open-source it right now.\n\n\nFurther Work\n\u00b6\n\n\nIf you have an idea for this library, or question, please file an issue for it!\n\n\nIn the short term roadmap we have\n\n\n\n\nPublish it to Maven Central\n\n\nCover 100% of RxJava testing APIs with DSL\n\n\nThinking about TestScheduler DSLs as well\n\n\n\n\nLicense\n\u00b6\n\n\nThis library is released under the \nMIT license",
            "title": "Tite"
        },
        {
            "location": "/#tite",
            "text": "A Kotlin DSL for gorgeous RxJava2 tests",
            "title": "TITE"
        },
        {
            "location": "/#motivation",
            "text": "RxJava2 gives us a handy testing API : besides  TestSubscriber  and  TestObserver , you also have a built-in  test()  API method available for every available reactive type, that shortcuts the retrieval of a  TestObserver  or  TestSubscriber  instance and streamlines your testing flow.    val letters = Observable.just(\"A\",\"B\",\"C\")\n\nletters\n    .test()\n    .assertValueCount(3)\n    .assertComplete()  Both  TestSubscriber  and  TestObserver  assertions let you get your tests done; but after using these APIs for a while, you may figure out they are not perfect ...   Nevertheless, Kotlin empowers developers with a new world of possibilities, including a new field of DSL grammars using language features like  infix notation  for functions representations,  lambdas extensions  over instance types and others.  With this in mind, Tite was born. It aims to apply some grammar over  TestSubscriber  and  TestObserver  APIs while improving these APIs discoverability as well.",
            "title": "Motivation"
        },
        {
            "location": "/#source-code",
            "text": "Check it on  Github",
            "title": "Source Code"
        },
        {
            "location": "/#setup",
            "text": "For now, Tite is available through Jitpack. To add it into your project :   Setup Jitpack as a Maven repository   allprojects {\n    repositories {\n        ...\n        maven { url 'https://jitpack.io' }\n    }\n}   Add this library to your dependencies. For an Android project   dependencies {\n    implementation 'com.github.ubiratansoares.tite:tite:$version'\n}  Check this project  releases  for the latest version.  This library will be available at Maven Central soon, I`m looking for some community feedback.",
            "title": "Setup"
        },
        {
            "location": "/#dsl-design",
            "text": "Tite DSL assumes that intentions for testing some reactive-type are grouped, under the following DSL blocks",
            "title": "DSL Design"
        },
        {
            "location": "/#conditions-before-performing-verifications",
            "text": "val   target   =   Observable . range ( 1 ,   5 )  given ( target )   { \n     beforeChecksAwait   { \n         untilEmissions   reach   2   // will ignore first two items \n     }  }",
            "title": "Conditions before performing verifications"
        },
        {
            "location": "/#verifying-emmited-values",
            "text": "val   numbers   =   Observable . just ( 1 ,   2 ,   3 )  given ( numbers )   { \n     verifyForEmissions   { \n         items   match   sequenceOf ( 1 ,   2 ,   3 ) \n     }  }",
            "title": "Verifying emmited values"
        },
        {
            "location": "/#verifying-signaled-error",
            "text": "val   expectedReason   =   IllegalStateException ( \"Ouch!\" )  val   broken   =   Flowable . error < Any >( reason )  given ( broken )   { \n     verifyWhenError   { \n         fails   byError   expectedReason \n     }  }",
            "title": "Verifying signaled error"
        },
        {
            "location": "/#verifying-lifecycle-of-a-sequence",
            "text": "val   neverStarts   =   Completable . never ()  given ( neverStarts )   { \n     assertThatSequence   { \n         should   notBe   terminated \n     }  }",
            "title": "Verifying lifecycle of a sequence"
        },
        {
            "location": "/#mixed-verifications",
            "text": "Of course, you can mix all this blocks under the same unit test context, putting some structure over the  fluent-and-chainable  way of traditional Java  val   words   =   Observable . just ( \"Adenor\" ,   \"Leonardo\" ,   \"Bacchi\" )  given ( words )   { \n\n     beforeChecksAwait   { \n         countingTime   until   3. seconds \n     } \n\n     assertThatSequence   { \n         should   be   completed \n         should   be   terminated \n         should   notBe   broken \n         should   be   subscribed \n     } \n\n     verifyForEmissions   { \n         items   match   sequenceOf ( \"Adenor\" ,   \"Leonardo\" ,   \"Bacchi\" ) \n         firstItem   shouldBe   \"Adenor\" \n         never   emmits   \"Parreira\" \n         never   emmits   \"Felip\u00e3o\" \n     }  }   If you want to learn all convered RxJava2 testing APIs without exploring the DSL itself, please, refer to this DSL unit tests .",
            "title": "Mixed verifications"
        },
        {
            "location": "/#building",
            "text": "In order to hack-and-mess with this library, we recommend   IntellijIDEA with Kotlin plugin  1.2.51  or newer   This library is builded with Gradle. The IDE should integrate seamlessly with this project via the default  Gradle wrapper .",
            "title": "Building"
        },
        {
            "location": "/#is-this-library-used-by-someone-somewhere",
            "text": "Yes. At  Stone  we are using it extensively into some new products (to be launched soon! \ud83d\ude80), but this library concept (and practical field validation) is older than those products, mine own, and I decided to open-source it right now.",
            "title": "Is this library used by someone / somewhere ?"
        },
        {
            "location": "/#further-work",
            "text": "If you have an idea for this library, or question, please file an issue for it!  In the short term roadmap we have   Publish it to Maven Central  Cover 100% of RxJava testing APIs with DSL  Thinking about TestScheduler DSLs as well",
            "title": "Further Work"
        },
        {
            "location": "/#license",
            "text": "This library is released under the  MIT license",
            "title": "License"
        }
    ]
}